module AresMUSH
  module Custom
    class SpellCastWithTargetCmd
      include CommandHandler
      attr_accessor :name, :target_name, :spell, :spell_list     
      
      def parse_args
       args = cmd.parse_args(ArgParser.arg1_equals_arg2)
       self.spell = titlecase_arg(args.arg1)
       self.target_name = titlecase_arg(args.arg2)
       
      end
     
     
      def handle
        #Reading Config Files
        self.spell_list = Global.read_config("spells")
        damage_inflicted = Global.read_config("spells", self.spell, "damage_inflicted")
        damage_desc = Global.read_config("spells", self.spell, "damage_desc")
        heal_points = Global.read_config("spells", self.spell, "heal_points")
        is_revive = Global.read_config("spells", self.spell, "is_revive")    
        lethal_mod = Global.read_config("spells", self.spell, "lethal_mod")
        attack_mod = Global.read_config("spells", self.spell, "attack_mod")
        defense_mod = Global.read_config("spells", self.spell, "defense_mod")
        spell_mod = Global.read_config("spells", self.spell, "spell_mod")
        stance = Global.read_config("spells", self.spell, "stance")        
        require_target = Global.read_config("spells", self.spell, "require_target")
        
        #Is enactor KO'd?
        if enactor.combatant.is_ko
          client.emit_failure "You cannot cast a spell while KO'd."
        else
          #Does spell exist and does it need a target?
          if self.spell_list.include?(self.spell)   
            if require_target == false
              client.emit_failure "This spell does not use a target. Do spell/cast <spell>."
            end
          
          
            #Inflicting Damage
            if damage_inflicted != nil
              if enactor.combat
                target = FS3Combat.find_named_thing(self.target_name, enactor)
                damage_msg = damage_inflicted.downcase
                damage_desc_msg = damage_desc.downcase
                severity = upcase_arg(damage_inflicted)
                if (target)
                    FS3Combat.inflict_damage(target, severity, "Test")
                    FS3Combat.emit_to_combat enactor.combat, "#{enactor.name} casts _#{self.spell}_, inflicting a #{damage_msg} on #{target.name}."
                    FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
                else 
                  client.emit_failure t('db.object_not_found')
                end
              else
                 client.emit_failure t('custom.not_in_combat')
              end
            end
              
            #Healing
            if heal_points != nil
            
              if enactor.combat
                  target = FS3Combat.find_named_thing(self.target_name, enactor)
                  wound = FS3Combat.worst_treatable_wound(target)
                  
                  if (wound)
                    FS3Combat.heal(wound, heal_points)
                    FS3Combat.emit_to_combat enactor.combat, t('custom.cast_heal', :name => enactor.name, :spell => self.spell, :target => target.name, :points => heal_points)
                    FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
                  else
                    FS3Combat.emit_to_combat enactor.combat, t('custom.cast_heal_no_effect', :name => enactor.name, :spell => self.spell, :target => target.name)
                    FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
                  end
                  
              else
                client.emit_failure t('custom.not_in_combat')
              end
            end  
          else 
            client.emit_failure t('custom.not_spell')
          end 
          #Reviving
          if is_revive == true
            
              if enactor.combat
                target = FS3Combat.find_named_thing(self.target_name, enactor)
                
                if (!target.combatant.is_ko)
                  client.emit_failure "#{target.name} is not knocked out."
                else
                  target.combatant.update(is_ko: false)
                  FS3Combat.emit_to_combat enactor.combat, t('custom.cast_revive', :name => enactor.name, :spell => self.spell, :target => target.name)
                  FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
                end
                
              else
                client.emit_failure t('custom.not_in_combat')
              end
              
          end            
            
          #Set Lethality Mods
          if lethal_mod != nil
            
              if enactor.combat
                  target = FS3Combat.find_named_thing(self.target_name, enactor)
                  current_mod = target.combatant.damage_lethality_mod
                  new_mod = current_mod + lethal_mod                
                  target.combatant.update(damage_lethality_mod: new_mod)
                  FS3Combat.emit_to_combat enactor.combat, t('cast_mod', :name => enactor.name, :spell => self.spell, :target => target, :mod => lethal_mod, :type => "lethality", :total_mod => target.combatant.damage_lethality_mod)
                  FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
              else
                client.emit_failure t('custom.not_in_combat')
              end
              
          end
                  
                   
          #Set Attack Mods
          if attack_mod != nil
            
              if enactor.combat
                  target = FS3Combat.find_named_thing(self.target_name, enactor)
                  current_mod = target.combatant.attack_mod
                  new_mod = current_mod + attack_mod
                  target.combatant.update(attack_mod: new_mod)
                  FS3Combat.emit_to_combat enactor.combat, t('custom.cast_mod', :name => enactor.name, :target => target.name, :spell => self.spell, :mod => attack_mod, :type => "attack", :total_mod => target.combatant.attack_mod)
                  FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
              else
                client.emit_failure t('custom.not_in_combat')
              end
              
          end
                   
          #Set Defense Mods
          if defense_mod != nil
            
              if enactor.combat
                  target = FS3Combat.find_named_thing(self.target_name, enactor)
                  current_mod = target.combatant.defense_mod
                  new_mod = current_mod + defense_mod                
                  target.combatant.update(defense_mod: new_mod)
                  FS3Combat.emit_to_combat enactor.combat, t('custom.cast_mod', :name => enactor.name, :target => target.name, :spell => self.spell, :mod => defense_mod, :type => "defense", :total_mod => target.combatant.defense_mod)
                  FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
              else
                client.emit_failure t('custom.not_in_combat')
              end
              
          end        
          
          #Set Spell Mods
          if spell_mod != nil
            
              if enactor.combat
                  target = FS3Combat.find_named_thing(self.target_name, enactor)
                  current_mod = target.spell_mod.to_i
                  new_mod = current_mod + spell_mod                
                  target.update(spell_mod: new_mod)
                  FS3Combat.emit_to_combat enactor.combat, t('custom.cast_mod', :name => enactor.name, :target => target.name, :spell => self.spell, :mod => spell_mod, :type => "spell", :total_mod => target.spell_mod)
                  FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
              else
                client.emit_failure t('custom.not_in_combat')
              end
              
          end        
          
          #Change stance
          if stance != nil
            
              if enactor.combat
                  target = FS3Combat.find_named_thing(self.target_name, enactor)                
                  target.combatant.update(stance: stance)
                  FS3Combat.emit_to_combat enactor.combat, t('custom.cast_stance', :name => enactor.name, :target => target.name, :spell => self.spell, :stance => stance)
                  FS3Combat.set_action(client, enactor, enactor.combat, enactor.combatant, FS3Combat::PassAction, "")
              else
                client.emit_failure t('custom.not_in_combat')
              end
              
          end                
         
        end
      end
    end
  end
end